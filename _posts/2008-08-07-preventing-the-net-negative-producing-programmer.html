---
layout: post
title: Preventing the Net Negative Producing Programmer
categories:
- General Agile
tags: []
status: publish
type: post
published: true
meta: {}
---
Jay Fields recently published a <a href="http://blog.jayfields.com/2008/08/elitist-or-optimist.html">blog post</a> where (amongst many other points) he mentioned the concept of the <a href="http://www.pyxisinc.com/NNPP_Article.pdf">Net Negative Producing Programmer</a>, referred to as NNPP.

I'd never heard that specific term before and I enjoyed the read. Almost every project that I have worked on had a healthy number of people who's efforts were borderline negative to the teams productivity. I say borderline because I've never actually measured it - but I have worked with people that would take a week to do a days work, and it would be defect ridden when they claimed that it is done.

The part that struck me about the paper though was that it said that dismissal of an NNPP is a last resort. I do agree with the paper that it argues against measuring the person with absolute statistics in making this decision, but on collaborative/agile projects, it's usually easy to spot the weak links. I can understand that it can be expensive and risky to fire someone, but software teams must have a way of weeding out these individuals, and removing them. I don't just mean moving them to another team; I believe that they should be laid off. I wouldn't even feel too bad about it, IT is still a high demand industry, and even the worst of the NNPP will find some giant company to disappear into.

There is a better way however, one that will prevent companies from getting into the position of having to worry about this in the first place. <strong>Improve the hiring standards</strong>. If you can keep the NNPP's out of your company in the first place, you don't have to worry about firing them.

At Thoughtworks, the interview process is pretty rigorous, there are phone interviews, a code submission, logic tests, and lengthy in-person interviews with people of varying roles. The highlight for me is the code submission. It's pretty telling from looking at a code submission whether the candidate is worth pursuing in the first place. I don't care how many languages and technologies someone claims to know - if they can't create an elegant and working solution to a short problem when the expected outputs are provided, then they most likely aren't top notch.

There is also a scale to the problems, from easy to hard. Personally, botching the easy problem is unacceptable, but I'm a slightly more forgiving with the hardest problem. In general, the reviewers are usually pretty harsh, so, it generally takes a good solution to even be considered acceptable. Oh, and experience level is factored in - junior candidates have to write pretty good code, but an experienced candidate needs to nail the code submission.

It's a HUGE differentiator. Every company that is serious about staffing the best talent (or even just good talent) should require a code submission.

I've even heard of some offices doing pair-programming during the interview. This is also a great idea. Someone may know how to write great code, but still not be good at actually doing it. I've paired with (non-Thoughtworks) people that were supposed to have 5+ years of experience and watched them struggle to write a method with a single for-loop and get it to compile. Alternatively, I've paired with people that are like some freakish melding of man and machine, writing with blinding speed, and what they write is beautiful. If I owned a company or ran an IT team, I'd do my best to get the freakish cyborg artist types.
